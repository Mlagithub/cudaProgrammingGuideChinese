\chapter{硬件实现}
\label{sec:hardimplementation}

CUDA架构是围绕一个可扩展的多线程流多处理器（SMs）阵列构建的。当主机上的CUDA程序调用内核网格，网格内块枚举并分发到有可用执行资源的多处理器上。线程块内线程在一个多处理器上并发执行且多个块可在一个流多处理器上并发执行。线程块终止时，便在空闲多处理器上发射新块。

流多处理器设计为能同时并发执行上百线程。为了管理如此多的线程，多处理器采用了一种称为SIMT（单指令，多线程）的独一无二的架构，这在\ref{sec:simt}节描述。指令流水线化以利用单线程内的指令级并行，流多处理器也使用如\ref{sec:hardwarethread}节所描述的硬件同时多线程利用线程级并行。与CPU核心不同地，指令顺序发射，而且没有分支预测和猜测执行。

\ref{sec:simt}节和\ref{sec:hardwarethread}节描述了所有设备都相同的流多处理器架构特色。\ref{sec:cc1x}、\ref{sec:cc2x}和\ref{sec:cc3x}分别提供了计算能力1.x、2.x和3.x的特性。

\section{SIMT 架构}
\label{sec:simt}
多处理器以32个为一组创建、管理、调度和执行并行线程，这32个线程称为束（warps）。束内包含的不同线程从同一程序地址开始，但它们有自己的指令地址计数器和寄存器状态，因此可自由分支和独立执行。束这个术语来源于纺织（weaving）这第一种并行线程技术。半束（half-warp）是束的前一半或后一半。四分之一束是指第一、第二、第三或第四个束的四分之一。

当多处理器得到一个或多个块执行，它会将块分割成束以执行，束被束调度器调度。块分割成束的方式总是相同的；束内线程是连续的，递增线程ID，第一个束包含线程0。\ref{sec:thread}给出了块内线程ID和线程索引的关系。

束每次执行一个相同的指令，所以如果束内所有32个线程在同一条路径上执行的话，会达到最高效率。如果由于数据依赖条件分支导致束分岔，束会顺序执行每个分支路径，而禁用不在此路径上的线程，直到所有路径完成，线程重新汇合到同一执行路径。分支岔开只会在同一束内发生；不同的束独立执行不管它们是执行相同或不同的代码路径。

在使用单指令控制多处理元素这点上，SIMT架构类似SIMD（单指令，多数据）向量组织方法。重要的不同在于SIMD组织方法会向应用暴露SIMD宽度，而SIMT指定单线程的执行和分支行为。与SIMD向量机相反，SIMT允许程序员为独立标量线程编写线程级并行代码，也为协作线程编写数据并行代码。为了正确性，程序员可忽略SIMT行为；只要维护束内线程很少分支的代码就可显著提升性能。实践中，这类似于传统代码中缓存线的角色：以正确性为目标进行设计时，可忽略缓存线尺寸，但如果以峰值性能为目标进行设计，在代码结构中就必须考虑。另外，向量架构要求软件将负载合并成向量，并手动管理分支。

如果一个束执行非原子指令为多个线程写入全局存储器或共享存储器的同一位置，串行写入该位置变量的数目依赖于设备的计算能力（参见\ref{sec:cc1x}、\ref{sec:cc2x}和\ref{sec:cc3x}）且那个线程最后写入无法确定。

如果束执行的原子指令（参见\ref{sec:atomic}）为束内多个线程读、修改和写入全局存储器的同一位置，每次读、修改和写入都会串行执行，但是他们执行的顺序没有定义。

\section{硬件多线程}
\label{sec:hardwarethread}

流多处理器处理的每个束的执行上下文（程序计数器，寄存器等）在束的生存期内被维护在片上。从一个执行上下文切换到另一个执行上下文没有消耗，而且在每个指令发射间，束调度器选择所有线程已准备好执行的束（活动束）并且向这些线程发射下个指令。

特别地，每个多处理器有一组32位的寄存器，这些寄存器被束分割而并行数据缓存或共享存储器在块内分割。

多处理器能够为一个内核常驻和同时处理的块和束的数量依赖于内核使用的寄存器和共享存储器数量和多处理器拥有的寄存器和共享存储器总量。同时每个多处理器有一个最大的常驻块数量和常驻束数量。这些限制包括多处理器上可用寄存器和共享存储器的数量是设备计算能力的函数，且其值在\ref{sec:cc}中给出。在计算能力1.x的设备上，如果多处理器没有足够的可用寄存器或共享存储器以处理至少一个块，内核将会发射失败。

块内总束数量如下：
\[
ceil(\frac{T}{W_{size}},1)
\]

\begin{itemize}
\item T是块内线程数，
\item $W_{size}$是束尺寸，等于32，
\item ceil(x,y)等于x向上取到y的整数倍
\end{itemize}

为线程块分配的总寄存器数量、总共享存储器数量可通过CUDA占用率计算器（CUDA Occupancy Calculator）得到，CUDA占用率计算器可在CUDA软件开发包中找到。
